/*
 * Copyright (c) 1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */ 

#ifndef __SGI_STL_ISTREAM
#define __SGI_STL_ISTREAM

#if defined(__sgi) && !defined(__GNUC__) && !defined(_STANDARD_C_PLUS_PLUS)
#error This header file requires the -LANG:std option
#endif

#include <ostream>              // Needed as a base class of basic_iostream.
                                // <ostream> includes <ios>, which in turn
                                // includes <iosfwd>.
#include <limits>               // Needed for class numeric_limits<>.

__STL_BEGIN_NAMESPACE

//----------------------------------------------------------------------
// Class basic_istream, a class that performs formatted input through
// a stream buffer.

// The second template parameter, _Traits, defaults to char_traits<_CharT>.
// The default is declared in header <iosfwd>, and it isn't declared here
// because C++ language rules do not allow it to be declared twice. 



template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits>
{
public:                         // Types
  typedef _CharT                     char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits                    traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

public:                         // Constructor and destructor.
  explicit basic_istream(basic_streambuf<_CharT, _Traits>* __buf);
  ~basic_istream();

public:                         // Nested sentry class.
  class sentry;
  struct _No_Skip_WS {};        // Dummy class used by sentry.

public:                         // Hooks for manipulators.  The arguments are
                                // function pointers.

  basic_istream& operator>> (basic_istream& (*__f)(basic_istream&))
    { return __f(*this); }

  basic_istream& operator>> (_Basic_ios& (*__f)(_Basic_ios&))
    { __f(*this); return *this; }

  basic_istream& operator>> (ios_base& (*__f)(ios_base&))
    { __f(*this); return *this; }
	

public:                         // Formatted input of numbers.
  basic_istream& operator>> (short& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (unsigned short& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (int& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (unsigned int& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (long& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (unsigned long& __val)
    { return _M_get_num(__val); }
#ifdef __STL_LONG_LONG
  basic_istream& operator>> (long long& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (unsigned long long& __val)
    { return _M_get_num(__val); }
#endif 

  basic_istream& operator>> (float& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (double& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (long double& __val)
    { return _M_get_num(__val); }

  basic_istream& operator>> (bool& __val)
    { return _M_get_num(__val); }
  basic_istream& operator>> (void*& __val)
    { return _M_get_num(__val); }

private:                        // Helper function for numeric input.
  template <class _Number> basic_istream& _M_get_num(_Number& __val);

public:                         // Copying characters into a streambuf.
  basic_istream& operator>>(basic_streambuf<_CharT, _Traits>*);

private:                        // Helper functions for copy to streambuf.
  template <class _Is_Delim>
  streamsize _M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __src,
                                basic_streambuf<_CharT, _Traits>* __dest,
                                _Is_Delim __is_delim,
                                bool __extract_delim, bool __rethrow);
  template <class _Is_Delim, class _Scan_Delim>
  streamsize _M_copy_buffered(basic_streambuf<_CharT, _Traits>* __src,
                              basic_streambuf<_CharT, _Traits>* __dest,
                              _Scan_Delim __scan_delim, _Is_Delim __is_delim,
                              bool __extract_delim, bool __rethrow);

public:                         // Unformatted input.
  streamsize gcount() const { return _M_gcount; }
  int_type peek();

public:                         // get() for single characters
  int_type get();
  basic_istream& get(char_type& __c);

public:                         // get() for character arrays.
  basic_istream& get(char_type* __s, streamsize __n, char_type __delim);
  basic_istream& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

public:                         // get() for streambufs
  basic_istream& get(basic_streambuf<_CharT, _Traits>& __buf,
                     char_type __delim);
  basic_istream& get(basic_streambuf<_CharT, _Traits>& __buf)
    { return get(__buf, this->widen('\n')); }

public:                         // getline()
  basic_istream& getline(char_type* __s, streamsize __n, char_type delim);
  basic_istream& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

public:                         // read(), readsome(), ignore()
  basic_istream& ignore();
  basic_istream& ignore(streamsize __n);
  basic_istream& ignore(streamsize __n, int_type __delim);

  basic_istream& read(char_type* __s, streamsize __n);
  streamsize readsome(char_type* __s, streamsize __n);

public:                         // putback
  basic_istream& putback(char_type __c);
  basic_istream& unget();

public:                         // Positioning and buffer control.
  int sync();

  pos_type tellg();
  basic_istream& seekg(pos_type __pos);
  basic_istream& seekg(off_type, ios_base::seekdir);

public:                        // Character array helper functions.
  template <class _Is_Delim>
  streamsize _M_read_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                                streamsize __N, _CharT* __s,
                                _Is_Delim __is_delim,
                                bool __extract_delim, bool __append_null,
                                bool __is_getline);
  template <class _Is_Delim, class _Scan_Delim>
  streamsize _M_read_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                              streamsize __N, _CharT* __s,
                              _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                              bool __extract_delim, bool __append_null,
                              bool __is_getline);
  template <class _Is_Delim>
  void _M_ignore_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                            _Is_Delim __is_delim,
                            bool __extract_delim, bool __set_eof);
  template <class _Is_Delim, class _Scan_Delim>
  void _M_ignore_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                          _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                          bool __extract_delim, bool __set_eof);
  template <class _Max_Chars, class _Is_Delim>
  streamsize _M_ignore_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                                  streamsize __N, _Max_Chars __max_chars,
                                  _Is_Delim __is_delim,
                                  bool __extract_delim, bool __set_eof);
  template <class _Max_Chars, class _Is_Delim, class _Scan_Delim>
  streamsize _M_ignore_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                                streamsize __N, _Max_Chars __max_chars,
                                _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                                bool __extract_delim, bool __set_eof);

public:                         // Helper functions for non-member extractors.
  void _M_formatted_get(_CharT& __c);
  void _M_formatted_get(_CharT* __s);
  void _M_skip_whitespace(bool __set_eof);

private:                        // Number of characters extracted by the
  streamsize _M_gcount;         // most recent unformatted input function.
};

// Non-member character and string extractor functions.

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>& 
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c) {
  __in._M_formatted_get(__c);
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>& 
operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c) {
  __in._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>& 
operator>>(basic_istream<char, _Traits>& __in, signed char& __c) {
  __in._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in;
}

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>& 
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s) {
  __in._M_formatted_get(__s);
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>& 
operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s) {
  __in._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>& 
operator>>(basic_istream<char, _Traits>& __in, signed char* __s) {
  __in._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in;
}

//----------------------------------------------------------------------
// Function object structs used by some member functions.

template <class _Traits>
struct _Is_wspace {
  typedef typename _Traits::char_type argument_type;
  typedef bool                        result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_wspace(const ctype<argument_type>* __ctype) : _M_ctype(__ctype) {}
  bool operator()(argument_type __c) const
    { return _M_ctype->is(ctype_base::space, __c); }
};

template <class _Traits>
struct _Is_wspace_null {
  typedef typename _Traits::char_type argument_type;
  typedef bool                        result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_wspace_null(const ctype<argument_type>* __ctype) : _M_ctype(__ctype) {}
  bool operator()(argument_type __c) const {
    return _Traits::eq(__c, argument_type()) || 
           _M_ctype->is(ctype_base::space, __c);
  }
};

template <class _Traits>
struct _Scan_for_wspace {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_wspace_null {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_wspace_null(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
#if 0
    __last = find_if(__first, __last,
                     bind2nd(_Eq_traits<_Traits>(), char_type()));
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
#endif
    char_type __c = *__first;
    while ((__first < __last)
	   && !(_Traits::eq(__c, char_type()))
	   && !(_M_ctype->is(ctype_base::space, __c))) {
	++__first;
	__c = *__first;
    }
    return(__first);
  }
};

template <class _Traits>
struct _Scan_for_not_wspace {
  typedef typename _Traits::char_type  char_type;
  typedef char_type*                   first_argument_type;
  typedef char_type*                   second_argument_type;
  typedef char_type*                   result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_not_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_not(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_char_val
{
  typedef typename _Traits::char_type char_type;
  typedef char_type*                  first_argument_type;
  typedef char_type*                  second_argument_type;
  typedef char_type*                  result_type;

  char_type _M_val;

  _Scan_for_char_val(char_type __value) : _M_val(__value) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last, bind2nd(_Eq_traits<_Traits>(), _M_val)); 
  }
};

template <class _Traits>
struct _Scan_for_int_val
{
  typedef typename _Traits::char_type char_type;
  typedef typename _Traits::int_type  int_type;
  typedef char_type*                  first_argument_type;
  typedef char_type*                  second_argument_type;
  typedef char_type*                  result_type;

  int_type _M_val;

  _Scan_for_int_val(int_type __value) : _M_val(__value) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last,
                   bind2nd(_Eq_int_traits<_Traits>(), _M_val));
  }
};


//----------------------------------------------------------------------
// Definitions of basic_istream<>'s noninline member functions.

// Constructor, destructor.

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>
  ::basic_istream(basic_streambuf<_CharT, _Traits>* __buf)
    : _Basic_ios(), _M_gcount(0)
{
  _Basic_ios::init(__buf);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream()
{}

// Helper function for formatted input of numbers.
template <class _CharT, class _Traits> template <class _Number>
basic_istream<_CharT, _Traits>& 
basic_istream<_CharT, _Traits>::_M_get_num(_Number& __val)
{
  sentry __sentry(*this);     // Skip whitespace.
  if (__sentry) {
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > _Num_get;
    ios_base::iostate __err = 0;
    __STL_TRY {
      use_facet<_Num_get>(getloc()).get(*this, 0, *this, __err, __val);
    }
    __STL_CATCH_ALL {
      this->_M_handle_exception(ios_base::badbit);
    }
    this->setstate(__err);
  }

  return *this;
}

// Copying characters into a streambuf.
template <class _CharT, class _Traits> 
basic_istream<_CharT, _Traits>& 
basic_istream<_CharT, _Traits>
  ::operator>>(basic_streambuf<_CharT, _Traits>* __dest)
{
  basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

  streamsize __n = 0;
  if (__src && __dest)
    __n = __src->egptr() != __src->gptr()
        ? _M_copy_buffered(__src, __dest,
                           _Project2nd<const _CharT*, const _CharT*>(),
                           _Constant_unary_fun<bool, int_type>(false),
                           false, true)
        : _M_copy_unbuffered(__src, __dest,
                             _Constant_unary_fun<bool, int_type>(false),
                             false, true);
  if (__n == 0)
    this->setstate(ios_base::failbit);

  return *this;
}

// Unformatted input

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
  typename _Traits::int_type __tmp = _Traits::eof();
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    __STL_TRY {
      __tmp = this->rdbuf()->sgetc();
    }
    __STL_CATCH_ALL {
      this->_M_handle_exception(ios_base::badbit);
    }
    if (_S_eof(__tmp))
      this->setstate(ios_base::eofbit);
  }

  return __tmp;
}


template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
  typename _Traits::int_type __tmp = _Traits::eof();
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    __STL_TRY {
      __tmp = this->rdbuf()->sbumpc();
    }
    __STL_CATCH_ALL {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!_S_eof(__tmp))
      this->_M_gcount = 1;
  }

  if (_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return __tmp;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& 
basic_istream<_CharT, _Traits>::get(_CharT& __c)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    __STL_TRY {
      __tmp = this->rdbuf()->sbumpc();
    }
    __STL_CATCH_ALL {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!_S_eof(__tmp)) {
      this->_M_gcount = 1;
      __c = _Traits::to_char_type(__tmp);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT* __s, streamsize __n,
                                    _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

      if (__buf->egptr() != __buf->gptr())
        this->_M_gcount =
          _M_read_buffered(__buf, __n - 1, __s,
                           bind2nd(_Eq_traits<_Traits>(), __delim),
                           _Scan_for_char_val<_Traits>(__delim),
                           false, true, false);
      else
        this->_M_gcount =
          _M_read_unbuffered(__buf, __n - 1, __s,
                             bind2nd(_Eq_traits<_Traits>(), __delim),
                             false, true, false);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& 
basic_istream<_CharT, _Traits>
  ::get(basic_streambuf<_CharT, _Traits>& __dest, _CharT __delim)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

    if (__src)
      this->_M_gcount = __src->egptr() != __src->gptr()
        ? _M_copy_buffered(__src, &__dest,
                           _Scan_for_char_val<_Traits>(__delim),
                           bind2nd(_Eq_traits<_Traits>(), __delim),
                           false, false)
        : _M_copy_unbuffered(__src, &__dest,
                             bind2nd(_Eq_traits<_Traits>(), __delim),
                             false, false);
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}

// Getline is essentially identical to get, except that it extracts
// the delimiter.
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(_CharT* __s, streamsize __n,
                                        _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
      this->_M_gcount = __buf->egptr() != __buf->gptr()
        ? _M_read_buffered(__buf, __n - 1, __s,
                           bind2nd(_Eq_traits<_Traits>(), __delim),
                           _Scan_for_char_val<_Traits>(__delim),
                           true, true, true)
        : _M_read_unbuffered(__buf, __n - 1, __s,
                             bind2nd(_Eq_traits<_Traits>(), __delim),
                             true, true, true);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}

// Read characters and discard them.  The standard specifies a single
// function with two arguments, each with a default.  We instead use
// three overloded functions, because it's possible to implement the
// first two more efficiently than the fully general third version.
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore()
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    int_type __c;
    __STL_TRY {
      __c = this->rdbuf()->sbumpc();
    }
    __STL_CATCH_ALL {
      _M_handle_exception(ios_base::badbit);
      return *this;
    }

    if (!_S_eof(__c))
      this->_M_gcount = 1;
    else
      this->setstate(ios_base::eofbit);
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = numeric_limits<streamsize>::max();

    if (__n == numeric_limits<int>::max()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = _M_ignore_buffered(__buf,
                               __maxss, _Const_streamsize(__maxss),
                               _Const_bool(false),
                               _Project2nd<const _CharT*, const _CharT*>(),
                               false, true);
      else
        _M_gcount = _M_ignore_unbuffered(__buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         _Const_bool(false), false, true);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = _M_ignore_buffered(__buf,
                               __n, minus<streamsize>(),
                               _Const_bool(false),
                               _Project2nd<const _CharT*, const _CharT*>(),
                               false, true);
      else
        _M_gcount = _M_ignore_unbuffered(__buf, __n, minus<streamsize>(),
                                         _Const_bool(false), false, true);
    }
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = numeric_limits<streamsize>::max();

    if (__n == numeric_limits<int>::max()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(__buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       bind2nd(_Eq_int_traits<_Traits>(),
                                               __delim),
                                       _Scan_for_int_val<_Traits>(__delim),
                                       true, true);
      else
        _M_gcount = _M_ignore_unbuffered(__buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         bind2nd(_Eq_int_traits<_Traits>(),
                                                 __delim),
                                         true, true);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(__buf,
                                       __n, minus<streamsize>(),
                                       bind2nd(_Eq_int_traits<_Traits>(),
                                               __delim),
                                       _Scan_for_int_val<_Traits>(__delim),
                                       true, true);
      else
        _M_gcount = _M_ignore_unbuffered(__buf, __n, minus<streamsize>(),
                                         bind2nd(_Eq_int_traits<_Traits>(),
                                                 __delim),
                                         true, true);
    }
  }

  return *this;
}

// Read n characters.  We don't look for any delimiter, and we don't
// put in a terminating null character.
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof()) {
    basic_streambuf<_CharT, _Traits>*__buf = this->rdbuf();
    if (__buf->gptr() != __buf->egptr()) 
      _M_gcount
        = _M_read_buffered(__buf, __n, __s,
                           _Constant_unary_fun<bool, int_type>(false),
                           _Project2nd<const _CharT*, const _CharT*>(),
                           false, false, false);
    else
      _M_gcount
        = _M_read_unbuffered(__buf, __n, __s,
                             _Constant_unary_fun<bool, int_type>(false),
                             false, false, false);
  }
  else
    this->setstate(ios_base::failbit);

  if (this->eof())
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}


// Read n or fewer characters.  We don't look for any delimiter, and
// we don't put in a terminating null character.
template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __nmax)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof() && __nmax >= 0) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __avail = __buf->in_avail();

    if (__avail == -1)
      this->_M_setstate_nothrow(ios_base::eofbit);

    else if (__avail == 0)
        ;

    else {
      if (__buf->gptr() != __buf->egptr()) 
        _M_gcount
          = _M_read_buffered(__buf, min(__avail, __nmax), __s,
                             _Constant_unary_fun<bool, int_type>(false),
                             _Project2nd<const _CharT*, const _CharT*>(),
                             false, false, false);
      else
        _M_gcount
          = _M_read_unbuffered(__buf, min(__avail, __nmax), __s,
                               _Constant_unary_fun<bool, int_type>(false),
                               false, false, false);
    }
  }
  else
    this->setstate(ios_base::failbit);

  if (this->eof())
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return _M_gcount;
}

// Putback

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& 
basic_istream<_CharT, _Traits>::putback(_CharT __c) {
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    if (!__buf || _S_eof(__buf->sputbackc(__c)))
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    if (!__buf || _Traits::eq_int_type(__buf->sungetc(), _Traits::eof()))
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}

// Positioning and buffer control.

template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (__buf) {
    if (__buf->pubsync() == -1) {
      this->setstate(ios_base::badbit);
      return -1;
    }
    else
      return 0;
  }
  else
    return -1;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  return !fail() && __buf ? __buf->pubseekoff(0, ios_base::cur, ios_base::in)
                          : pos_type(-1);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!fail() && __buf)
    __buf->pubseekpos(__pos, ios_base::in);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!fail() && __buf)
    __buf->pubseekoff(__off, __dir, ios_base::in);
  return *this;
}

// Formatted input of characters and character arrays.

template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT& __c)
{
//typename _Traits::int_type __tmp = _Traits::eof();

  sentry __sentry(*this); // Skip whitespace.

  if (__sentry) {
    typename _Traits::int_type __tmp;

    __STL_TRY {
      __tmp = this->rdbuf()->sbumpc();
    }
    __STL_CATCH_ALL {
      this->_M_handle_exception(ios_base::badbit);
      return;
    }

    if (!_S_eof(__tmp))
      __c = _Traits::to_char_type(__tmp);
    else 
      this->setstate(ios_base::eofbit | ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT* __s)
{
  typename _Traits::int_type __tmp = _Traits::eof();

  sentry __sentry(*this); // Skip whitespace.

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __nmax = this->width() > 0
      ? this->width() - 1
      : numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
    streamsize __n = __buf->gptr() != __buf->egptr()
      ? _M_read_buffered(__buf, __nmax, __s,
                         _Is_wspace_null<_Traits>(_M_ctype_facet()),
                         _Scan_wspace_null<_Traits>(_M_ctype_facet()),
                         false, true, false)
      : _M_read_unbuffered(__buf, __nmax, __s,
                           _Is_wspace_null<_Traits>(_M_ctype_facet()),
                           false, true, false);
    if (__n == 0)
      this->setstate(ios_base::failbit);
  }
  this->width(0);
}

// This member function does not construct a sentry object, because
// it is called from sentry's constructor.  
template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_skip_whitespace(bool __set_eof)
{
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!__buf)
    this->setstate(ios_base::badbit);
  else if (__buf->gptr() != __buf->egptr())
    _M_ignore_buffered(__buf,
                       not1(_Is_wspace<_Traits>(_M_ctype_facet())),
                       _Scan_for_not_wspace<_Traits>(_M_ctype_facet()),
                       false, __set_eof);
  else
    _M_ignore_unbuffered(__buf,
                         not1(_Is_wspace<_Traits>(_M_ctype_facet())),
                         false, __set_eof);
}


//---------------------------------------------------------------------------
// istream's helper functions.

// A generic function for unbuffered input.  We stop when we reach EOF,
// or when we have extracted __N characters, or when the function object
// __is_delim return true.  In the last case, it extracts the character
// for which __is_delim is true, if and only if __extract_delim is true. 
// It appends a null character to the end of the string; this means that
// it may store up to __N + 1 characters.  
//
// __is_getline governs two corner cases: reading __N characters without
// encountering delim or eof (in which case failbit is set if __is_getline
// is true); and reading __N characters where the __N+1'st character is
// eof (in which case eofbit is set if __is_getline is true).
//
// It is assumed that __is_delim never throws.
//
// Return value is the number of characters extracted, including the
// delimiter if it is extracted.  Note that the number of characaters
// extracted isn't necessarily the same as the number stored.
template <class _CharT, class _Traits> template <class _Is_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_read_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                       streamsize __N, _CharT* __s,
                       _Is_Delim __is_delim,
                       bool __extract_delim, bool __append_null,
                       bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;

  // The operations that can potentially throw are sbumpc, snextc, and sgetc.
  __STL_TRY {
    int_type __c = __buf->sgetc();
    for (;;) {
      if (_S_eof(__c)) {
        if (__n < __N || __is_getline)
          __status |= ios_base::eofbit;
        break;
      }

      else if (__is_delim(__c)) {
        if (__extract_delim) {  // Extract and discard current character.
          __buf->sbumpc();
          ++__n;
        }
        break;
      }

      else if (__n == __N) {
        if (__is_getline)
          __status |= ios_base::failbit;
        break;
      }
        
      *__s++ = _Traits::to_char_type(__c);
      ++__n;
      __c = __buf->snextc();
    }
  }
  __STL_CATCH_ALL {
    _M_handle_exception(ios_base::badbit);
    *__s = _CharT();
    return __n;
  }

  if (__append_null)
    *__s = _CharT();
  if (__status)
    this->setstate(__status);    // This might throw.
  return __n;
}

// Much like _M_read_unbuffered, but with one additional function object:
// __scan_delim(first, last) returns the first pointer p in [first, last)
// such that __is_delim(p) is true.  
template <class _CharT, class _Traits>
template <class _Is_Delim, class _Scan_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_read_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                     streamsize __N, _CharT* __s,
                     _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                     bool __extract_delim, bool __append_null,
                     bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  bool __done    = false;


  __STL_TRY {
    while (__buf->egptr() != __buf->gptr() && !__done) {
      const _CharT* __first = __buf->gptr();
      const _CharT* __last  = __buf->egptr();
      ptrdiff_t __request = __N - __n;

      const _CharT* __p  = __scan_delim(__first, __last);
      ptrdiff_t __chunk = min(__p - __first, __request);
      _Traits::copy(__s, __first, __chunk);
      __s += __chunk;
      __n += __chunk;
#pragma set woff 3968
      __buf->gbump(__chunk);
#pragma reset woff 3968

      // We terminated by finding delim.
      if (__p != __last && __p - __first <= __request) {
        if (__extract_delim) {
          __n += 1;
          __buf->gbump(1);
        }
        __done = true;
      }

      // We terminated by reading all the characters we were asked for.
      else if(__n == __N) {
        // Find out if we have reached eof.  This matters for getline.
        if (__is_getline) {
          if (__chunk == __last - __first) {
            if (_S_eof(__buf->sgetc()))
              __status |= ios_base::eofbit;            
          }
          else
            __status |= ios_base::failbit;
        }
        __done   = true;
      }

      // The buffer contained fewer than __N - __n characters.  Either we're
      // at eof, or we should refill the buffer and try again.
      else {
        if (_S_eof(__buf->sgetc())) {
          __status |= ios_base::eofbit;
          __done = true;
        }
      }
    } // Close the while loop.
  }
  __STL_CATCH_ALL {
    this->_M_handle_exception(ios_base::badbit);
    __done = true;
  }

  if (__done) {
    if (__append_null)
      *__s = _CharT();
    if (__status != 0)
      this->setstate(__status);   // This might throw.
    return __n;
  }

  // If execution has reached this point, then we have an empty buffer but
  // we have not reached eof.  What that means is that the streambuf has
  // decided to switch from buffered to unbuffered input.  We switch to
  // to _M_read_unbuffered.

  return __n + _M_read_unbuffered(__buf, __N - __n, __s, __is_delim,
                                  __extract_delim,__append_null,__is_getline);
}

// A generic unbuffered function for ignoring characters.  We stop
// when we reach EOF, or when the function object __is_delim returns
// true.  In the last case, it extracts the character for which
// __is_delim is true, if and only if __extract_delim is true.
template <class _CharT, class _Traits>
template <class _Is_Delim>
void basic_istream<_CharT, _Traits>
  ::_M_ignore_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                         _Is_Delim __is_delim,
                         bool __extract_delim, bool __set_eof)
{
  bool __done = false;
  ios_base::iostate __status = 0;

  __STL_TRY {
    while (!__done) {
      int_type __c = __buf->sbumpc();

      if (_S_eof(__c)) {
        __done = true;
        if (__set_eof)
          __status |= ios_base::eofbit;
      }

      else if (__is_delim(__c)) {
        __done = true;
        if (!__extract_delim)
          if (_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
            __status |= ios_base::failbit;
      }
    }
  }
  __STL_CATCH_ALL {
    this->_M_handle_exception(ios_base::badbit);
  }

  this->setstate(__status);
}

// A generic buffered function for ignoring characters.  Much like
// _M_ignore_unbuffered, but with one additional function object:
// __scan_delim(first, last) returns the first pointer p in [first,
// last) such that __is_delim(p) is true.
template <class _CharT, class _Traits>
template <class _Is_Delim, class _Scan_Delim>
void basic_istream<_CharT, _Traits>
  ::_M_ignore_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                       _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                       bool __extract_delim, bool __set_eof)
{
  bool __at_eof      = false;
  bool __found_delim = false;

  __STL_TRY {
    while (__buf->egptr() != __buf->gptr() && !__at_eof && !__found_delim) {
      const _CharT* __p = __scan_delim(__buf->gptr(), __buf->egptr());
#pragma set woff 3968
      __buf->gbump(__p - __buf->gptr());
#pragma reset woff 3968
    
      if (__p != __buf->egptr()) { // We found delim, so we're done.
        if (__extract_delim)
          __buf->gbump(1);
        __found_delim = true;
      }

      else                         // No delim.  Try to refil the buffer.
        __at_eof = _S_eof(__buf->sgetc());
    }                              // Close the while loop.
  }
  __STL_CATCH_ALL {
    _M_handle_exception(ios_base::badbit);
    return;
  }

  if (__at_eof) {
    if (__set_eof)
      this->setstate(ios_base::eofbit);
    return;
  }
  if (__found_delim)
    return;

  // If execution has reached this point, then we have an empty buffer but
  // we have not reached eof.  What that means is that the streambuf has
  // decided to switch from a buffered to an unbuffered mode.  We switch 
  // to _M_ignore_unbuffered.
  _M_ignore_unbuffered(__buf, __is_delim, __extract_delim, __set_eof);
}

// Overloaded versions of _M_ignore_unbuffered and _M_ignore_unbuffered 
// with an explicit count __N.  Return value is the number of
// characters extracted.
//
// The function object __max_chars takes two arguments, __N and __n
// (the latter being the number of characters we have already read), 
// and returns the maximum number of characters to read from the buffer.
// We parameterize _M_ignore_buffered so that we can use it for both
// bounded and unbounded input; for the former the function object should
// be minus<>, and for the latter it should return a constant maximum value.
template <class _CharT, class _Traits>
template <class _Max_Chars, class _Is_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_ignore_unbuffered(basic_streambuf<_CharT, _Traits>* __buf,
                         streamsize __N, _Max_Chars __max_chars,
                         _Is_Delim __is_delim,
                         bool __extract_delim, bool __set_eof)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  
  __STL_TRY {
    while (__N-__n > 0) {
      int_type __c = __buf->sbumpc();

      if (_S_eof(__c)) {
        if (__set_eof)
          __status |= ios_base::eofbit;
        break;
      }

      else if (__is_delim(__c)) {
        if (__extract_delim)
          ++__n;
        else if (_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
          __status |= ios_base::failbit;

        break;
      }
    }
  }
  __STL_CATCH_ALL {
    _M_handle_exception(ios_base::badbit);
  }

  if (__status)
    this->setstate(__status);   // This might throw.
  return __n;
}

template <class _CharT, class _Traits>
template <class _Max_Chars, class _Is_Delim, class _Scan_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_ignore_buffered(basic_streambuf<_CharT, _Traits>* __buf,
                       streamsize __N,
                       _Max_Chars __max_chars,
                       _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                       bool __extract_delim, bool __set_eof)
{
  streamsize __n = 0;
  bool __at_eof = false;
  bool __done   = false;

  __STL_TRY {
    while (__buf->egptr() != __buf->gptr() && !__done) {
      ptrdiff_t __avail = __buf->egptr() - __buf->gptr();
      streamsize __m = __N-__n;
    
      if (__avail >= __m) {       // We have more characters than we need.
        const _CharT* __last = __buf->gptr() + __m;
        const _CharT* __p = __scan_delim(__buf->gptr(), __last);
        ptrdiff_t __chunk = __p - __buf->gptr();
        __n += __chunk;
        __buf->gbump(__chunk);

        if (__extract_delim && __p != __last) {
          __n += 1;
          __buf->gbump(1);
        }

        __done = true;
      }

      else {
        const _CharT* __p = __scan_delim(__buf->gptr(), __buf->egptr());
        ptrdiff_t __chunk = __p - __buf->gptr();
        __n += __chunk;
        __buf->gbump(__chunk);

        if (__p != __buf->egptr()) { // We found delim.
          if (__extract_delim) {
            __n += 1;
            __buf->gbump(1);
          }

          __done = true;
        }

        // We didn't find delim.  Try to refill the buffer.
        else if (_S_eof(__buf->sgetc())) {
          __done   = true;
          __at_eof = true;
        } 
      }
    } // Close the while loop.
  }
  __STL_CATCH_ALL {
    this->_M_handle_exception(ios_base::badbit);
    return __n;
  }

  if (__at_eof && __set_eof)
    this->setstate(ios_base::eofbit);

  if (__done)
    return __n;

  // If execution has reached this point, then we have an empty buffer but
  // we have not reached eof.  What that means is that the streambuf has
  // decided to switch from buffered to unbuffered input.  We switch to
  // to _M_ignore_unbuffered.

  return __n + _M_ignore_unbuffered(__buf, __N, __max_chars,
                                    __is_delim, __extract_delim, __set_eof);
}

// Helper function: try to push back a character to a streambuf, 
// return true if the pushback succeeded.  Does not throw.
template <class _CharT, class _Traits> 
inline bool
__pushback(basic_streambuf<_CharT, _Traits>* __buf, _CharT __c)
{
  __STL_TRY {
    const typename _Traits::int_type __eof = _Traits::eof();
    return !_Traits::eq_int_type(__buf->sputbackc(__c), __eof);
  }
  __STL_CATCH_ALL {
    return false;
  }
}

// This is a very simple loop that reads characters from __src and puts
// them into __dest.  It looks complicated because of the (standard-
// mandated) exception handling policy.
//
// We stop when we get an exception, when we fail to insert into the 
// output streambuf, or when __is_delim is true.
template <class _CharT, class _Traits> 
template <class _Is_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __src,
                       basic_streambuf<_CharT, _Traits>* __dest,
                       _Is_Delim __is_delim,
                       bool __extract_delim, bool __rethrow)
{
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;

  for (;;) {
    int_type __c;

    // Get a character. If there's an exception, catch and (maybe) rethrow it.
    __STL_TRY {
      __c = __src->sbumpc();
    }
    __STL_CATCH_ALL {
      // See 27.6.1.2.3, paragraph 13.
      if (__rethrow && __extracted == 0)
        _M_handle_exception(ios_base::failbit);
      break;
    }

    // If we failed to get a character, then quit.
    if (_S_eof(__c)) {
      __status |= ios_base::eofbit;
      break;
    }

    // If it's the delimiter, then quit.
    else if (__is_delim(__c)) {
      if (!__extract_delim && !__pushback(__src, _Traits::to_char_type(__c)))
        __status |= ios_base::failbit;
      break;
    }

    else {
      // Try to put the character in the output streambuf.
      bool __failed = false;
      __STL_TRY {
        if (!_S_eof(__dest->sputc(__c)))
          ++__extracted;
        else
          __failed = true;
      }
      __STL_CATCH_ALL {
        __failed = true;
      }

      // If we failed to put the character in the output streambuf, then
      // try to push it back to the input streambuf.
      if (__failed && !__pushback(__src, _Traits::to_char_type(__c)))
        __status |= ios_base::failbit;
    }
  }

  this->setstate(__status);
  return __extracted;
}
      
// Buffered copying from one streambuf to another.  We copy the characters
// in chunks, rather than one at a time.  We still have to worry about all
// of the error conditions we checked in _M_copy_unbuffered, plus one more:
// the streambuf might decide to switch from a buffered to an unbuffered mode.

template <class _CharT, class _Traits> 
template <class _Is_Delim, class _Scan_Delim>
streamsize basic_istream<_CharT, _Traits>
  ::_M_copy_buffered(basic_streambuf<_CharT, _Traits>* __src,
                     basic_streambuf<_CharT, _Traits>* __dest,
                     _Scan_Delim __scan_delim, _Is_Delim __is_delim,
                     bool __extract_delim, bool __rethrow)
                     
{
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;

  _CharT* __first = __src->gptr();
  ptrdiff_t __avail = __src->egptr() - __first;
  for (;;) {
    streamsize __n = 0;
    const _CharT* __last = __scan_delim(__first, __src->egptr());

    // Try to copy the entire input buffer to the output buffer.
    __STL_TRY {
      __n = __dest->sputn(__first, __extract_delim && __last != __src->egptr()
                                     ? (__last - __first) + 1
                                     : (__last - __first));
      __src->gbump(__n);
      __extracted += __n;
    }
    __STL_CATCH_ALL {
      break;
    }

    if (__n < __avail)          // We found the delimiter, or else failed to
      break;                    // copy some characters.

    // We copied all of the characters.  Try to refill the buffer.
    else {
      int_type __c;
      __STL_TRY {
        __c = __src->sgetc();
      }
      __STL_CATCH_ALL {
        // See 27.6.1.2.3, paragraph 13.
        if (__rethrow && __extracted == 0)
          this->_M_handle_exception(ios_base::failbit);
      }

      // Three possibilities: we succeeded in refilling the buffer, or 
      // we got EOF, or the streambuf has switched to unbuffered mode.
      __first = __src->gptr();
      __avail = __src->egptr() - __first;

      if (__avail > 0)
        ;
      else if (_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }
      else 
        return __extracted + _M_copy_unbuffered(__src, __dest, __is_delim,
                                                __extract_delim, __rethrow);
    }
  }

  if (__status)
    this->setstate(__status);   // This might throw.
  return __extracted;
} 



//----------------------------------------------------------------------
// Nested sentry class.

template <class _CharT, class _Traits>
class basic_istream<_CharT, _Traits>::sentry {
private:
  bool _M_ok;
  basic_streambuf<_CharT, _Traits>* _M_buf;

  // Helper functions for constructor.
  void _M_init_skip(basic_istream<_CharT, _Traits>& __is) {
    if (__is.good()) {
      if (__is.tie())
        __is.tie()->flush();

      __is._M_skip_whitespace(true);
    }

    if (!__is.good())
      __is.setstate(ios_base::failbit);

    _M_ok = __is.good();
  }

  void _M_init_noskip(basic_istream<_CharT, _Traits>& __is) {
    if (__is.good()) {
      if (__is.tie())
        __is.tie()->flush();

      if (!_M_buf)
        __is.setstate(ios_base::badbit);
    }
    else
      __is.setstate(ios_base::failbit);

    _M_ok = __is.good();
  }
    
public:
  typedef _Traits traits_type;

  explicit sentry(basic_istream<_CharT, _Traits>& __is,
                  bool __noskipws = false)
    : _M_buf(__is.rdbuf())
  {
    if (__noskipws || !(__is.flags() & ios_base::skipws))
      _M_init_noskip(__is);
    else
      _M_init_skip(__is);
  }
 
  // Calling this constructor is the same as calling the previous one with 
  // __noskipws = true, except that it doesn't require a runtime test.
  sentry(basic_istream<_CharT, _Traits>& __is, _No_Skip_WS)
    : _M_buf(__is.rdbuf())
  {
    _M_init_noskip(__is);
  }  

  ~sentry() {}
  operator bool() const { return _M_ok; }

private:                        // Disable assignment and copy constructor.
  sentry(const sentry&);
  void operator=(const sentry&);
};

//----------------------------------------------------------------------
// istream manipulator.

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
  typedef typename basic_istream<_CharT, _Traits>::sentry      _Sentry;
  typedef typename basic_istream<_CharT, _Traits>::_No_Skip_WS _No_Skip_WS;
  _Sentry __sentry(__is, _No_Skip_WS()); // Don't skip whitespace.
  if (__sentry)
    __is._M_skip_whitespace(true);
  return __is;
}

//----------------------------------------------------------------------
// Class iostream.

template <class _CharT, class _Traits>
class basic_iostream 
  : public basic_istream<_CharT, _Traits>,
    public basic_ostream<_CharT, _Traits>
{
public:
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

  explicit basic_iostream(basic_streambuf<_CharT, _Traits>* __buf);
  virtual ~basic_iostream();
};

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>
  ::basic_iostream(basic_streambuf<_CharT, _Traits>* __buf)
    : _Basic_ios(),
      basic_istream<_CharT, _Traits>(__buf),
      basic_ostream<_CharT, _Traits>(__buf)
{
  _Basic_ios::init(__buf);  
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{}

__STL_END_NAMESPACE

#endif /* __SGI_STL_ISTREAM */

// Local Variables:
// mode:C++
// End:
